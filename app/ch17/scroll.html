<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Lander</title>
    <script src='js/jquery.min.js'></script>
    <script src='js/underscore.js'></script>
    <script src='js/quintus.js'></script>
    <script src='js/quintus_input.js'></script>
    <script src='js/quintus_sprites.js?1'></script>
    <script src='js/quintus_scenes.js'></script>
    <script src='js/quintus_anim.js'></script>

    <!--<meta name="viewport" content="width=320, user-scalable=no"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name=apple-mobile-web-app-capable content=yes>
    <meta name=apple-mobile-web-app-status-bar-style content=black>
    <style>
      body { padding:0px; margin:0px; background-color:#1e7572; }
      #quintus { background-color:#1e7572; }
    </style>
  </head>
  <body>
    <div></div>
    <canvas id='quintus' width='320' height='480'></canvas>
    <script>
      function debug(info){
        var dr = document.getElementById('debug');
        //dr.innerHTML = info;
      }
      var Q = Quintus()
              .include("Input,Sprites,Scenes,Anim")
              .setup();
 
      Q.followOverlap = function(o1,o2) {
            var collided =  !((o1.p.movedY+o1.p.h-1<o2.p.movedY) || (o1.p.movedY>o2.p.movedY+o2.p.h-1) ||
             (o1.p.x+o1.p.w-1<o2.p.x) || (o1.p.x>o2.p.x+o2.p.w-1));
            if(collided){
              console.log("1y:"+o1.p.movedY+",1h:"+o1.p.h+",2y:"+o2.p.movedY+",2h:"+o2.p.h);
            }
            return collided;
      };
      Q.height = window.innerHeight;
      Q.controls();

      $(window).resize(function() {
        console.log('window was resized:'+window.innerHeight);
        var canvas = document.getElementById('quintus');
        canvas.height = window.innerHeight;
        Q.height = window.innerHeight;
        //Q.InputSystem.drawButtons();
      });

      Q.ResistSprite = Q.StaticFollowSprite.extend({
        init: function(props) {
        this._super(_({
          resistForce:0.5,
          resistDuration:30,
          isResist:true
        }).extend(props));
          this.p.property = props;
        },

        step: function(dt) {
          this._super(dt);
          if(Q.followOverlap(Q.leader, this)){
           
            if(this.p.isResist){
              Q.leader.p.resistDuration = this.p.resistDuration;
              Q.leader.p.resistForce = this.p.resistForce;
            }else{
              Q.leader.p.isCrashed = true;
            }
            var newMovedY = Q.leader.p.movedY - (Q.height +  1000* Math.random());
            var xgap = Q.width - this.p.w;
            this.p.property.x = xgap * Math.random();
            this.p.property.movedY = newMovedY; 
            this.p.property.isResist = this.p.isResist;
            console.log("will new a object, resist is:"+this.p.isResist);
            var resistAgin = new Q.ResistSprite(this.p.property);
            this.parent.insert(resistAgin);
            this.parent.remove(this);
          }else if((this.p.movedY - Q.leader.p.movedY) > Q.height){
            //console.log("pass a object, resist is:"+this.p.isResist+",leader:"+Q.leader.p.movedY+", this movedY:"+this.p.movedY);
            var newMovedY = Q.leader.p.movedY - (Q.height +  1000* Math.random());
            var xgap = Q.width - this.p.w;
            console.log("pass a object, resist is:"+this.p.isResist+",leader:"+Q.leader.p.movedY+", this movedY:"+this.p.movedY+"new moved:"+newMovedY);
            this.p.property.movedY = newMovedY;
            this.p.property.x = xgap * Math.random();
            this.p.property.isResist = this.p.isResist;
            
            var resistAgin = new Q.ResistSprite(this.p.property);
            this.parent.insert(resistAgin);
            this.parent.remove(this);
          }
        },
        draw:function(ctx){
          this._super(ctx);
        }
      });

      Q.Ship = Q.CenterSprite.extend({
        resistDuration:0,
        resistForce:0.5,
        step: function(dt) {
          if(Q.inputs['left'] || Q.inputs['right'] || Q.inputs['fire']){
            this.p.gravity = 20;
          }
          if(!this.p.stepCount){
              this.p.stepCount = 0;  
          }
          this.p.stepCount++; 

          if(this.dead) return;
          var p = this.p;
          // Set our horizontal force
          p.fx = 0;
          if(Q.inputs['left']) { p.fx -= p.thrustX; }
          if(Q.inputs['right']) { p.fx += p.thrustX; }

          // Set our vertical force

          if(Q.inputs['fire'] || Q.inputs['up']){
              //console.log('fire clicked');
              p.fy = -p.thrustY/2.0;
              p.asset = p.thrustStateImage;
             }else if(Q.inputs['down']){
                 p.fy = p.thrustY/4.0;
                 p.asset = p.thrustStateImage;
            }else {
            
            //I can change the image on the fly. 
            p.fy = 0;
            p.asset = p.normalStateImage;
           }

          // Calculate our y and x acceleration
          //I am have idea of ax and ay.
          var resistAce = 0;
          p.resistDuration --;
          if(p.resistDuration <0){
            p.resistDuration = 0;
          }else{
            resistAce = p.resistForce;
          }
          p.ay = p.gravity + p.fy / p.m - resistAce * p.vy;
          p.ax = p.fx / p.m;
          
          // Let our super-class update our x and y
          //console.log("child p.backgorund:"+p.backgorund);
          //console.log("will call super:ay:"+p.ay);

          this._super(dt);
          var height = Math.floor(-p.movedY);
          height -= height % 3;
          Q.titleScreen.p.subTitle = "当前高度:"+  height;
          if(this.p.stepCount % 30){
            var passedTime = Math.floor((new Date().getTime() - Q.gameStartTime)/1000);
            Q.titleScreen.p.thirdTitle = "当前耗时:"+passedTime+"秒";
          }
          var col;
          if(col = this.checkCollision()) {
            if(col == 1) {
              //&& Math.abs(p.vy) < 30
              //if(p.vy > 0) { 
              //  p.vy = 0;
              //}
            } else if(col == 2){
              this.parent.insert(new Q.Explosion(p.x,p.y,p.vx,p.vy,this.imageData));
              this.parent.remove(this);
              this.dead=true;
            }
          }

          // Force our lander to stay in our box 
          // and zero out our velocity when we hit a wall
          if(p.y < 0) { 
              Q.currentStage = Q.stageMaps[Q.currentStage];
              Q.stageScene(Q.currentStage);
            }
          if(p.y > Q.height- p.h) { p.y = Q.height - p.h; p.vy = 0; }
          if(p.x < 0) { p.x = 0; p.vx = 0; }
          if(p.x > Q.width - p.w) {
              p.x = Q.width - p.w;
              p.vx = 0;
           }
        },
        checkCollision: function(){
          //for(var pos =0; pos < Q.collides.length; pos ++){
          //  if(Q.followOverlap(this, Q.collides[pos])){
          //    console.log('detect collision');
          //    return 2;
          //  }
          //}
          //console.log('not collided');
          if(this.p.isCrashed){
            return 2;
          }
          return 1;
        },
        checkCollisionOld: function() {
          var bgData = Q.backgroundPixels;
          // Get a integer based position from our
          // x and y values
          var bgx = Math.floor(this.p.x);
          var bgy = Math.floor(this.p.y);
          // Calculate the initial offset into our background
          var bgOffset = bgx * 4 + bgy * bgData.width * 4 + 3;

          // Pull out our data easy access
          var pixels = this.imageData.data;
          var bgPixels = bgData.data;

          for(var sy=0;sy < this.imageData.height;sy++) {
            for(var sx=0;sx < this.imageData.width;sx++) {
              // Check for an existing pixel on our ship
              if(pixels[sx*4 + sy * this.imageData.width * 4 + 3]) {

                // Then check for a matching existing pixel on the background
                // starting from our bgOffest and then indexing in from there
                if(bgPixels[bgOffset + sx*4 + sy * bgData.width * 4]) {

                  // Next check if we are at the bottom of the lander
                  // if so return 1, to indicate that we might be landing
                  // instead of crashing
                  if(sy > this.imageData.height - 2) {
                    return 1;
                    } else {
                    // Otherwise return 2 and...Boom!
                    return 2;
                  }
                }
              }
            }
          }
          return 0;
        }

      });

      Q.Explosion = Q.GameObject.extend({
        init: function(x,y,vx,vy,imgData) {

          // Set up a container for our pixels
          this.particles = []

          // Grab the lander's image data
          var landerData = imgData.data;


          // Create a 3x3 pixel-data 
          // image data container to use for blitting down the road
          this.pixelData = Q.ctx.createImageData(3,3);
          this.drawPixel = this.pixelData.data; 

          // Pixels are going to be exploding out from 
          // the center of the lander
          var centerX = imgData.width / 2;
          var centerY = imgData.height / 2;

          // Loop over each fourth pixel of the lander image
          for(var sy=0;sy < imgData.height;sy+=4) {
            for(var sx=0;sx < imgData.width;sx+=4) {

              // Offset into the 1 dimension pixel data array
              var loc = sx*4 + sy * imgData.width * 4;

              // If theres a lander pixel here
              if(landerData[loc + 3]) {

                // Get the direction of the pixel from center
                var distX = sx - centerX;
                var distY = sy - centerY;

                // Add a new particle
                this.particles.push({
                  x: x + sx,  // starting position x
                  y: y + sy,  // starting position y
                  lifetime: 5,  // remaining lifetime
                  r: landerData[loc] + 20,  // make it a little redder
                  g: landerData[loc+1],
                  b: landerData[loc+2],
                  a: landerData[loc+3],
                  // For particle velocity, use the ships velocity,
                  // plus a random direction emanating from the center of the ship
                  vx: vx/6 +  distX * 5 *(Math.random()+0.5), 
                  vy: vy/6 + distY * 5 * (Math.random()+0.5)
                });
              }
            }
          }
        },

        step: function(dt) {

          var bgData = Q.backgroundPixels;
          var pixels = bgData.data;

          for(var i =0,len=this.particles.length;i<len;i++) {
            var v = this.particles[i];
            if(v.lifetime > 0) {

              var oldx = v.x, oldy = v.y;
              v.vy += 20 * dt;
              v.x += dt * v.vx;
              v.y += dt * v.vy;
              var loc = Math.floor(v.x)*4 + Math.floor(v.y) * bgData.width * 4;
              if(pixels[loc + 3]) {
                v.x = oldx;
                v.y = oldy;
                v.vy *= -0.2;
                v.vx *= -0.2;
              }
              v.lifetime -= dt;
            }
            if(v.lifetime <= 0) { 

              Q.stageScene(Q.currentStage); return; }
          }

        },
        draw: function(ctx) {
          for(var i=0,len=this.particles.length;i<len;i++) {
            var v = this.particles[i];

            if(v.lifetime > 0) {
              for(var l=0;l<36;l+=4) {
                this.drawPixel[l+0] = v.r;
                this.drawPixel[l+1] = v.g;
                this.drawPixel[l+2] = v.b;
                this.drawPixel[l+3] = v.a;
              }

              ctx.putImageData(this.pixelData,v.x,v.y);
            }
          }

        }
      });

      Q.load(['chars.png','sprites.json','cloud1.png','cloud2.png', 'cloud3.png','stone1.png', 'bottom.png','ball.png','level.json','lander.png','star_back.png','backgroundv1.png', 
              'lander_thrust.png','easy.png','brick1.png', 'mapv1.png','mapv2.png', 'mapv3.png', 'mapv4.png'], function() {
        Q.height = window.innerHeight;
       /**
        Q.compileSheets('chars.png','sprites.json');
        Q.animations('player', {
        run_right: { frames: _.range(7,-1,-1), rate: 1/15}, 
        run_left: { frames: _.range(19,11,-1), rate:1/15 },
        fire_right: { frames: [9,10,10], next: 'stand_right', rate: 1/30 },
        fire_left: { frames: [20,21,21], next: 'stand_left', rate: 1/30 },
        stand_right: { frames: [8], rate: 1/5 },
        stand_left: { frames: [20], rate: 1/5 },
        fall_right: { frames: [2], loop: false },
        fall_left: { frames: [14], loop: false }
      });

      Q.animations('blob', {
        run_right: { frames: _.range(0,2), rate: 1/5 },
        run_left: { frames: _.range(2,4), rate: 1/5 }
      });
**/
        console.log('current height is:'+ Q.height);
        
        Q.StepLogic = Q.Sprite.extend({
          init:function(props){
              this._super(_({


              }).extend(props));
              this.p.prevHeight = 0;
          },
          step:function(dt){
              var height = Math.abs(Q.leader.p.movedY);
              if(height > Q.endHeight - Q.height){
                //Q.leader.p.gravity = 0;
                //Q.leader.p.vx = 0;
                //Q.leader.p.vy = 0;
                if(!this.p.forkedPlane){
                  this.p.forkedPlane = true;
                  this.p.stepCount = Q.leader.p.stepCount;
                  var plane = new Q.StaticFollowSprite({asset:"plane.png", x:Math.random()*(Q.width-80), y:0, movedY:-20000, movedX:100});
                  this.parent.insert(plane);
                  Q.leader.p.vy = 30;
                }else{
                  //Q.leader.p.vy > 30;
                  Q.leader.p.vy =30;
                  if(height > Q.endHeight){
                     Q.pauseGame(); 
                  }
                }
              }else{
                  if((Q.leader.p.stepCount % 91)== 0 && Math.random()>0.7){
                    var gap = this.p.prevHeight - Q.leader.p.movedY;
                    if(gap < Q.height){
                      return;
                    }
                    console.log('create a bomb');
                    var bomb = new Q.ResistSprite({asset:"stone1.png", x:Math.random()*(Q.width-60), y:0, movedY:Q.leader.p.movedY - Q.height, movedX:100, isResist:false});
                    this.parent.insert(bomb);
                  }

              }
          },
          draw:function(ctx){

          }
        });

        Q.scene("level1",new Q.Scene(function(stage) {
          //stage.insert(new Q.Sprite({ asset: "backgroundv1.png" }));
          //stage.insert(new Q.Sprite({ asset: "mapv4.png" }));
          //var movingBack = new Q.MovingBackground({ asset: "star_back.png" });
          var targetHeight = 20000;
          var starBack = new Q.StarSprite({}); 
          stage.insert(starBack);

          //var addMan = new Q.StaticFollowSprite({ x:0, y:0, z:3, sheet:'man', movedY:-800, movedX:100});
          var ground = new Q.StaticFollowSprite({asset:"bottom.png", x:0, y:Q.height-180, movedY:35, movedX:0, removePassed:false});

          var logic = new Q.StepLogic({});
          //var staticBall = new Q.StaticFollowSprite({asset:'ball.png', x:200, y:30, movedY:40, movedX:120, removePassed:true});

          //console.log('loaded ball width:'+staticBall.p.w+', ground:'+ground.p.w);
          Q.titleScreen = new Q.TitleScreen({title:'目标高度:'+targetHeight, z:0});
          
          var collid1 = new Q.ResistSprite({asset:"cloud1.png", x:Math.random()*(Q.width-80), y:0, movedY:-1000, movedX:100, removePassed:false, resistForce:0.7, resistDuration:30, isResist:true});
          stage.insert(collid1);

          var collid1 = new Q.ResistSprite({asset:"cloud2.png", x:Math.random()*(Q.width-80), y:0, movedY:-1500, movedX:100, removePassed:false, resistForce:0.7, resistDuration:30, isResist:true});
          stage.insert(collid1);

          var collid1 = new Q.ResistSprite({asset:"cloud3.png", x:Math.random()*(Q.width-80), y:0, movedY:-2000, movedX:100, removePassed:false, resistForce:0.7, resistDuration:30, isResist:true});
          stage.insert(collid1);

          var collid1 = new Q.ResistSprite({asset:"cloud2.png", x:Math.random()*(Q.width-80), y:0, movedY:-2500, movedX:100, removePassed:false, resistForce:0.7, resistDuration:30, isResist:true});
          stage.insert(collid1);

          //var crash = new Q.ResistSprite({asset:"stone1.png", x:Math.random()*(Q.width-60), y:0, movedY:-600, movedX:100, isResist:false});
          //stage.insert(crash);

          //var crash2 = new Q.ResistSprite({asset:"stone1.png", x:Math.random()*(Q.width-60), y:0, movedY:-300, movedX:100, isResist:false});
          //stage.insert(crash2);

          //var crash3 = new Q.ResistSprite({asset:"stone1.png", x:Math.random()*(Q.width-60), y:0, movedY:-100, movedX:100, isResist:false});
          //stage.insert(crash2);

          //var plane = new Q.StaticFollowSprite({asset:"plane.png", x:Math.random()*(Q.width-80), y:0, movedY:-20000, movedX:100});
          //stage.add(plane);
          
          stage.insert(ground);
          //stage.insert(staticBall);
          stage.insert(Q.titleScreen);
          stage.insert(logic);
          //stage.insert(addMan);
          debug("innerHeight:"+Q.height+", height:"+Q.innerHeight);
          var ship = stage.insert(new Q.Ship({
            asset: 'ball.png',
            normalStateImage:'ball.png',
            thrustStateImage:'ball.png',
            x:       145, // X Position
            y:       (Q.height)/2.0, // Y Position
            centerY: (Q.height)/2.0,
            gravity: 20,  // Gravity
            m:       1,   // Ship’s Mass
            thrustX: 160,  // Horizontal Thrust
            thrustY: 80,  // Vertical Thrust    
            //background: movingBack,
            movedX: 0,
            movedY: 0,
            resistDuration:0,
            resistForce:0
          }));
          Q.leader = ship;
          Q.endHeight = targetHeight;
          //ship.p.background = movingBack;
          //console.log('ship.p.background:'+ ship.p.background+", movingBack:"+movingBack+", initial movedY:"+ship.p.movedY);
          Q.backgroundPixels = Q.imageData(Q.asset('mapv4.png'));
          ship.imageData = Q.imageData(Q.asset('ball.png'));
        }));


        //Q.stageMaps = {'level':'level1','level1':'level2', 'level2':'level3', 'level3':'level4',"level4":"level"};
        Q.currentStage = "level1";
        Q.stageScene("level1");
        Q.gameStartTime = new Date().getTime();
        console.log('start time is:'+Q.gameStartTime);

      });
    </script>
  </body>
</html>